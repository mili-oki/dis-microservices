package com.example.dis.payments_service.service;

import com.example.dis.payments_service.client.NotificationsClient;
import com.example.dis.payments_service.client.OrderDto;
import com.example.dis.payments_service.client.OrderStatus;
import com.example.dis.payments_service.client.OrdersClient;
import com.example.dis.payments_service.client.PaymentNotification;
import com.example.dis.payments_service.messaging.PaymentEventPublisher;
import com.example.dis.payments_service.model.Payment;
import com.example.dis.payments_service.model.PaymentStatus;
import com.example.dis.payments_service.repository.PaymentRepository;
import com.example.dis.payments_service.messaging.PaymentNotification;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.server.ResponseStatusException;

import java.math.BigDecimal;
import java.time.OffsetDateTime;
import java.util.List;

@Service
public class PaymentService {

    private final PaymentRepository paymentRepository;
    private final OrdersClient ordersClient;
    private final NotificationsClient notificationsClient;
    private final PaymentEventPublisher publisher;
    
    public PaymentService(PaymentRepository paymentRepository,
                          OrdersClient ordersClient,
                          NotificationsClient notificationsClient,
                          PaymentEventPublisher publisher) {
        this.paymentRepository = paymentRepository;
        this.ordersClient = ordersClient;
        this.notificationsClient = notificationsClient;
        this.publisher = publisher;
    }
    
    public List<Payment> getAll() {
        return paymentRepository.findAll();
    }

    public Payment getById(Long id) {
        return paymentRepository.findById(id)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Payment not found"));
    }

    @Transactional
    public Payment pay(Long orderId, BigDecimal amount) {
        // 1) proveri da order postoji i da je PENDING
        OrderDto order = ordersClient.getOrder(orderId);
        if (order == null) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Order not found");
        }
        if (order.getStatus() != OrderStatus.PENDING) {
            throw new ResponseStatusException(HttpStatus.CONFLICT, "Only PENDING orders can be paid");
        }
        if (amount == null || amount.signum() <= 0) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Invalid amount");
        }

        // 2) "obradi" plaćanje (ovde je simulacija – uspeva uvek ako je amount > 0)
        Payment p = new Payment();
        p.setOrderId(orderId);
        p.setAmount(amount);
        p.setStatus(PaymentStatus.SUCCESS);
        p.setCreatedAt(OffsetDateTime.now());
        p = paymentRepository.save(p);

        // 3) ako je success → potvrdi order u orders-service
        ordersClient.confirm(orderId);
        
        // pošalji notifikaciju
        try {
            PaymentNotification notif = new PaymentNotification();
            notif.setOrderId(orderId);
            notif.setAmount(amount);
            notif.setStatus("SUCCESS");
            notif.setMessage("Payment processed and order confirmed");
            notificationsClient.notifyPayment(notif);
            
            publisher.publish(new PaymentNotification(
                    orderId,
                    amount,
                    "SUCCESS",
                    "Payment captured"
            ));
        } catch (Exception ex) {
            // ne ruši plaćanje ako notifikacija padne; samo zaloguj
            // (kasnije će MQ rešiti pouzdanost)
            System.err.println("Failed to notify notifications-service: " + ex.getMessage());
        }

        return p;
    }
}
